// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package main 

import (
	"strconv"

	flatbuffers "github.com/google/flatbuffers/go"

)

type LanguageType int32

const (
	LanguageTypeDUMMY       LanguageType = 0
	LanguageTypeALL         LanguageType = 1
	LanguageTypeOO          LanguageType = 2
	LanguageTypeCXX         LanguageType = 3
	LanguageTypeC           LanguageType = 4
	LanguageTypeC_FAMILY    LanguageType = 5
	LanguageTypeJAVA        LanguageType = 6
	LanguageTypeCSHARP      LanguageType = 7
	LanguageTypeOBJECTIVE_C LanguageType = 8
	LanguageTypeSMALI       LanguageType = 9
	LanguageTypeSOLIDITY    LanguageType = 10
	LanguageTypeCOBOL85     LanguageType = 11
	LanguageTypePYTHON3     LanguageType = 12
)

var EnumNamesLanguageType = map[LanguageType]string{
	LanguageTypeDUMMY:       "DUMMY",
	LanguageTypeALL:         "ALL",
	LanguageTypeOO:          "OO",
	LanguageTypeCXX:         "CXX",
	LanguageTypeC:           "C",
	LanguageTypeC_FAMILY:    "C_FAMILY",
	LanguageTypeJAVA:        "JAVA",
	LanguageTypeCSHARP:      "CSHARP",
	LanguageTypeOBJECTIVE_C: "OBJECTIVE_C",
	LanguageTypeSMALI:       "SMALI",
	LanguageTypeSOLIDITY:    "SOLIDITY",
	LanguageTypeCOBOL85:     "COBOL85",
	LanguageTypePYTHON3:     "PYTHON3",
}

var EnumValuesLanguageType = map[string]LanguageType{
	"DUMMY":       LanguageTypeDUMMY,
	"ALL":         LanguageTypeALL,
	"OO":          LanguageTypeOO,
	"CXX":         LanguageTypeCXX,
	"C":           LanguageTypeC,
	"C_FAMILY":    LanguageTypeC_FAMILY,
	"JAVA":        LanguageTypeJAVA,
	"CSHARP":      LanguageTypeCSHARP,
	"OBJECTIVE_C": LanguageTypeOBJECTIVE_C,
	"SMALI":       LanguageTypeSMALI,
	"SOLIDITY":    LanguageTypeSOLIDITY,
	"COBOL85":     LanguageTypeCOBOL85,
	"PYTHON3":     LanguageTypePYTHON3,
}

func (v LanguageType) String() string {
	if s, ok := EnumNamesLanguageType[v]; ok {
		return s
	}
	return "LanguageType(" + strconv.FormatInt(int64(v), 10) + ")"
}

type LiteralType int32

const (
	LiteralTypedummy_type   LiteralType = 0
	LiteralTypenumber_type  LiteralType = 1
	LiteralTypechar_type    LiteralType = 2
	LiteralTypestring_type  LiteralType = 3
	LiteralTypeboolean_type LiteralType = 4
	LiteralTypenull_type    LiteralType = 5
)

var EnumNamesLiteralType = map[LiteralType]string{
	LiteralTypedummy_type:   "dummy_type",
	LiteralTypenumber_type:  "number_type",
	LiteralTypechar_type:    "char_type",
	LiteralTypestring_type:  "string_type",
	LiteralTypeboolean_type: "boolean_type",
	LiteralTypenull_type:    "null_type",
}

var EnumValuesLiteralType = map[string]LiteralType{
	"dummy_type":   LiteralTypedummy_type,
	"number_type":  LiteralTypenumber_type,
	"char_type":    LiteralTypechar_type,
	"string_type":  LiteralTypestring_type,
	"boolean_type": LiteralTypeboolean_type,
	"null_type":    LiteralTypenull_type,
}

func (v LiteralType) String() string {
	if s, ok := EnumNamesLiteralType[v]; ok {
		return s
	}
	return "LiteralType(" + strconv.FormatInt(int64(v), 10) + ")"
}

type DiffType int32

const (
	DiffTypeMATCHED      DiffType = 0
	DiffTypeADDED        DiffType = 1
	DiffTypeDELETED      DiffType = 2
	DiffTypeCHANGED_FROM DiffType = 3
	DiffTypeCHANGED_TO   DiffType = 4
)

var EnumNamesDiffType = map[DiffType]string{
	DiffTypeMATCHED:      "MATCHED",
	DiffTypeADDED:        "ADDED",
	DiffTypeDELETED:      "DELETED",
	DiffTypeCHANGED_FROM: "CHANGED_FROM",
	DiffTypeCHANGED_TO:   "CHANGED_TO",
}

var EnumValuesDiffType = map[string]DiffType{
	"MATCHED":      DiffTypeMATCHED,
	"ADDED":        DiffTypeADDED,
	"DELETED":      DiffTypeDELETED,
	"CHANGED_FROM": DiffTypeCHANGED_FROM,
	"CHANGED_TO":   DiffTypeCHANGED_TO,
}

func (v DiffType) String() string {
	if s, ok := EnumNamesDiffType[v]; ok {
		return s
	}
	return "DiffType(" + strconv.FormatInt(int64(v), 10) + ")"
}

type DeltaType int32

const (
	DeltaTypeMATCH  DeltaType = 0
	DeltaTypeADD    DeltaType = 1
	DeltaTypeDEL    DeltaType = 2
	DeltaTypeMOVE   DeltaType = 3
	DeltaTypeUPDATE DeltaType = 4
)

var EnumNamesDeltaType = map[DeltaType]string{
	DeltaTypeMATCH:  "MATCH",
	DeltaTypeADD:    "ADD",
	DeltaTypeDEL:    "DEL",
	DeltaTypeMOVE:   "MOVE",
	DeltaTypeUPDATE: "UPDATE",
}

var EnumValuesDeltaType = map[string]DeltaType{
	"MATCH":  DeltaTypeMATCH,
	"ADD":    DeltaTypeADD,
	"DEL":    DeltaTypeDEL,
	"MOVE":   DeltaTypeMOVE,
	"UPDATE": DeltaTypeUPDATE,
}

func (v DeltaType) String() string {
	if s, ok := EnumNamesDeltaType[v]; ok {
		return s
	}
	return "DeltaType(" + strconv.FormatInt(int64(v), 10) + ")"
}

type CloneType int32

const (
	CloneTypeMAYBE CloneType = 0
	CloneTypeYES   CloneType = 1
	CloneTypeNO    CloneType = 2
)

var EnumNamesCloneType = map[CloneType]string{
	CloneTypeMAYBE: "MAYBE",
	CloneTypeYES:   "YES",
	CloneTypeNO:    "NO",
}

var EnumValuesCloneType = map[string]CloneType{
	"MAYBE": CloneTypeMAYBE,
	"YES":   CloneTypeYES,
	"NO":    CloneTypeNO,
}

func (v CloneType) String() string {
	if s, ok := EnumNamesCloneType[v]; ok {
		return s
	}
	return "CloneType(" + strconv.FormatInt(int64(v), 10) + ")"
}

type ChangeType int32

const (
	ChangeTypeUNCHANGED ChangeType = 0
	ChangeTypeADD       ChangeType = 1
	ChangeTypeDEL       ChangeType = 2
)

var EnumNamesChangeType = map[ChangeType]string{
	ChangeTypeUNCHANGED: "UNCHANGED",
	ChangeTypeADD:       "ADD",
	ChangeTypeDEL:       "DEL",
}

var EnumValuesChangeType = map[string]ChangeType{
	"UNCHANGED": ChangeTypeUNCHANGED,
	"ADD":       ChangeTypeADD,
	"DEL":       ChangeTypeDEL,
}

func (v ChangeType) String() string {
	if s, ok := EnumNamesChangeType[v]; ok {
		return s
	}
	return "ChangeType(" + strconv.FormatInt(int64(v), 10) + ")"
}

type Element struct {
	_tab flatbuffers.Table
}

func GetRootAsElement(buf []byte, offset flatbuffers.UOffsetT) *Element {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &Element{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *Element) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *Element) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *Element) Kind() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *Element) MutateKind(n int32) bool {
	return rcv._tab.MutateInt32Slot(4, n)
}

func (rcv *Element) Text() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *Element) Pos() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *Element) MutatePos(n int32) bool {
	return rcv._tab.MutateInt32Slot(8, n)
}

func (rcv *Element) Length() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *Element) MutateLength(n int32) bool {
	return rcv._tab.MutateInt32Slot(10, n)
}

func (rcv *Element) Child(obj *Element, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *Element) ChildLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *Element) Tail() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *Element) Extra(obj *Anonymous0) *Anonymous0 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(Anonymous0)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *Element) Line() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *Element) MutateLine(n int32) bool {
	return rcv._tab.MutateInt32Slot(18, n)
}

func (rcv *Element) Column() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(20))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *Element) MutateColumn(n int32) bool {
	return rcv._tab.MutateInt32Slot(20, n)
}

func (rcv *Element) Label() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(22))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *Element) MutateLabel(n float32) bool {
	return rcv._tab.MutateFloat32Slot(22, n)
}

func (rcv *Element) Change() DiffType {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(24))
	if o != 0 {
		return DiffType(rcv._tab.GetInt32(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *Element) MutateChange(n DiffType) bool {
	return rcv._tab.MutateInt32Slot(24, int32(n))
}

func (rcv *Element) Keep() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(26))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

func (rcv *Element) MutateKeep(n bool) bool {
	return rcv._tab.MutateBoolSlot(26, n)
}

func (rcv *Element) Id() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(28))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *Element) MutateId(n int32) bool {
	return rcv._tab.MutateInt32Slot(28, n)
}

func ElementStart(builder *flatbuffers.Builder) {
	builder.StartObject(13)
}
func ElementAddKind(builder *flatbuffers.Builder, kind int32) {
	builder.PrependInt32Slot(0, kind, 0)
}
func ElementAddText(builder *flatbuffers.Builder, text flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(text), 0)
}
func ElementAddPos(builder *flatbuffers.Builder, pos int32) {
	builder.PrependInt32Slot(2, pos, 0)
}
func ElementAddLength(builder *flatbuffers.Builder, length int32) {
	builder.PrependInt32Slot(3, length, 0)
}
func ElementAddChild(builder *flatbuffers.Builder, child flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(4, flatbuffers.UOffsetT(child), 0)
}
func ElementStartChildVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func ElementAddTail(builder *flatbuffers.Builder, tail flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(5, flatbuffers.UOffsetT(tail), 0)
}
func ElementAddExtra(builder *flatbuffers.Builder, extra flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(6, flatbuffers.UOffsetT(extra), 0)
}
func ElementAddLine(builder *flatbuffers.Builder, line int32) {
	builder.PrependInt32Slot(7, line, 0)
}
func ElementAddColumn(builder *flatbuffers.Builder, column int32) {
	builder.PrependInt32Slot(8, column, 0)
}
func ElementAddLabel(builder *flatbuffers.Builder, label float32) {
	builder.PrependFloat32Slot(9, label, 0.0)
}
func ElementAddChange(builder *flatbuffers.Builder, change DiffType) {
	builder.PrependInt32Slot(10, int32(change), 0)
}
func ElementAddKeep(builder *flatbuffers.Builder, keep bool) {
	builder.PrependBoolSlot(11, keep, false)
}
func ElementAddId(builder *flatbuffers.Builder, id int32) {
	builder.PrependInt32Slot(12, id, 0)
}
func ElementEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type Anonymous0 struct {
	_tab flatbuffers.Table
}

func GetRootAsAnonymous0(buf []byte, offset flatbuffers.UOffsetT) *Anonymous0 {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &Anonymous0{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *Anonymous0) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *Anonymous0) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *Anonymous0) Unit(obj *Unit) *Unit {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(Unit)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *Anonymous0) Literal(obj *Literal) *Literal {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(Literal)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func Anonymous0Start(builder *flatbuffers.Builder) {
	builder.StartObject(2)
}
func Anonymous0AddUnit(builder *flatbuffers.Builder, unit flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(unit), 0)
}
func Anonymous0AddLiteral(builder *flatbuffers.Builder, literal flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(literal), 0)
}
func Anonymous0End(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type Unit struct {
	_tab flatbuffers.Table
}

func GetRootAsUnit(buf []byte, offset flatbuffers.UOffsetT) *Unit {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &Unit{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *Unit) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *Unit) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *Unit) Filename() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *Unit) Revision() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *Unit) Language() LanguageType {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return LanguageType(rcv._tab.GetInt32(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *Unit) MutateLanguage(n LanguageType) bool {
	return rcv._tab.MutateInt32Slot(8, int32(n))
}

func (rcv *Unit) Item() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *Unit) MutateItem(n int32) bool {
	return rcv._tab.MutateInt32Slot(10, n)
}

func UnitStart(builder *flatbuffers.Builder) {
	builder.StartObject(4)
}
func UnitAddFilename(builder *flatbuffers.Builder, filename flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(filename), 0)
}
func UnitAddRevision(builder *flatbuffers.Builder, revision flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(revision), 0)
}
func UnitAddLanguage(builder *flatbuffers.Builder, language LanguageType) {
	builder.PrependInt32Slot(2, int32(language), 0)
}
func UnitAddItem(builder *flatbuffers.Builder, item int32) {
	builder.PrependInt32Slot(3, item, 0)
}
func UnitEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type Literal struct {
	_tab flatbuffers.Table
}

func GetRootAsLiteral(buf []byte, offset flatbuffers.UOffsetT) *Literal {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &Literal{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *Literal) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *Literal) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *Literal) Type() LiteralType {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return LiteralType(rcv._tab.GetInt32(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *Literal) MutateType(n LiteralType) bool {
	return rcv._tab.MutateInt32Slot(4, int32(n))
}

func LiteralStart(builder *flatbuffers.Builder) {
	builder.StartObject(1)
}
func LiteralAddType(builder *flatbuffers.Builder, type_ LiteralType) {
	builder.PrependInt32Slot(0, int32(type_), 0)
}
func LiteralEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type Delta struct {
	_tab flatbuffers.Table
}

func GetRootAsDelta(buf []byte, offset flatbuffers.UOffsetT) *Delta {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &Delta{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *Delta) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *Delta) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *Delta) Src() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *Delta) Dst() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *Delta) Diff(obj *Diff, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *Delta) DiffLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func DeltaStart(builder *flatbuffers.Builder) {
	builder.StartObject(3)
}
func DeltaAddSrc(builder *flatbuffers.Builder, src flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(src), 0)
}
func DeltaAddDst(builder *flatbuffers.Builder, dst flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(dst), 0)
}
func DeltaAddDiff(builder *flatbuffers.Builder, diff flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(diff), 0)
}
func DeltaStartDiffVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func DeltaEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type Diff struct {
	_tab flatbuffers.Table
}

func GetRootAsDiff(buf []byte, offset flatbuffers.UOffsetT) *Diff {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &Diff{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *Diff) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *Diff) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *Diff) Type() DeltaType {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return DeltaType(rcv._tab.GetInt32(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *Diff) MutateType(n DeltaType) bool {
	return rcv._tab.MutateInt32Slot(4, int32(n))
}

func (rcv *Diff) Delta(obj *Anonymous1) *Anonymous1 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(Anonymous1)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func DiffStart(builder *flatbuffers.Builder) {
	builder.StartObject(2)
}
func DiffAddType(builder *flatbuffers.Builder, type_ DeltaType) {
	builder.PrependInt32Slot(0, int32(type_), 0)
}
func DiffAddDelta(builder *flatbuffers.Builder, delta flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(delta), 0)
}
func DiffEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type Anonymous1 struct {
	_tab flatbuffers.Table
}

func GetRootAsAnonymous1(buf []byte, offset flatbuffers.UOffsetT) *Anonymous1 {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &Anonymous1{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *Anonymous1) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *Anonymous1) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *Anonymous1) Match(obj *Match) *Match {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(Match)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *Anonymous1) Add(obj *Add) *Add {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(Add)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *Anonymous1) Del(obj *Del) *Del {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(Del)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *Anonymous1) Move(obj *Move) *Move {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(Move)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *Anonymous1) Update(obj *Update) *Update {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(Update)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func Anonymous1Start(builder *flatbuffers.Builder) {
	builder.StartObject(5)
}
func Anonymous1AddMatch(builder *flatbuffers.Builder, match flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(match), 0)
}
func Anonymous1AddAdd(builder *flatbuffers.Builder, add flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(add), 0)
}
func Anonymous1AddDel(builder *flatbuffers.Builder, del flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(del), 0)
}
func Anonymous1AddMove(builder *flatbuffers.Builder, move flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(move), 0)
}
func Anonymous1AddUpdate(builder *flatbuffers.Builder, update flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(4, flatbuffers.UOffsetT(update), 0)
}
func Anonymous1End(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type Match struct {
	_tab flatbuffers.Table
}

func GetRootAsMatch(buf []byte, offset flatbuffers.UOffsetT) *Match {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &Match{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *Match) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *Match) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *Match) Src() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *Match) MutateSrc(n int32) bool {
	return rcv._tab.MutateInt32Slot(4, n)
}

func (rcv *Match) Dst() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *Match) MutateDst(n int32) bool {
	return rcv._tab.MutateInt32Slot(6, n)
}

func MatchStart(builder *flatbuffers.Builder) {
	builder.StartObject(2)
}
func MatchAddSrc(builder *flatbuffers.Builder, src int32) {
	builder.PrependInt32Slot(0, src, 0)
}
func MatchAddDst(builder *flatbuffers.Builder, dst int32) {
	builder.PrependInt32Slot(1, dst, 0)
}
func MatchEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type Add struct {
	_tab flatbuffers.Table
}

func GetRootAsAdd(buf []byte, offset flatbuffers.UOffsetT) *Add {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &Add{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *Add) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *Add) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *Add) Src() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *Add) MutateSrc(n int32) bool {
	return rcv._tab.MutateInt32Slot(4, n)
}

func (rcv *Add) Dst() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *Add) MutateDst(n int32) bool {
	return rcv._tab.MutateInt32Slot(6, n)
}

func (rcv *Add) Position() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *Add) MutatePosition(n int32) bool {
	return rcv._tab.MutateInt32Slot(8, n)
}

func AddStart(builder *flatbuffers.Builder) {
	builder.StartObject(3)
}
func AddAddSrc(builder *flatbuffers.Builder, src int32) {
	builder.PrependInt32Slot(0, src, 0)
}
func AddAddDst(builder *flatbuffers.Builder, dst int32) {
	builder.PrependInt32Slot(1, dst, 0)
}
func AddAddPosition(builder *flatbuffers.Builder, position int32) {
	builder.PrependInt32Slot(2, position, 0)
}
func AddEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type Del struct {
	_tab flatbuffers.Table
}

func GetRootAsDel(buf []byte, offset flatbuffers.UOffsetT) *Del {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &Del{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *Del) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *Del) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *Del) Src() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *Del) MutateSrc(n int32) bool {
	return rcv._tab.MutateInt32Slot(4, n)
}

func DelStart(builder *flatbuffers.Builder) {
	builder.StartObject(1)
}
func DelAddSrc(builder *flatbuffers.Builder, src int32) {
	builder.PrependInt32Slot(0, src, 0)
}
func DelEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type Move struct {
	_tab flatbuffers.Table
}

func GetRootAsMove(buf []byte, offset flatbuffers.UOffsetT) *Move {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &Move{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *Move) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *Move) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *Move) Src() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *Move) MutateSrc(n int32) bool {
	return rcv._tab.MutateInt32Slot(4, n)
}

func (rcv *Move) Dst() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *Move) MutateDst(n int32) bool {
	return rcv._tab.MutateInt32Slot(6, n)
}

func (rcv *Move) Position() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *Move) MutatePosition(n int32) bool {
	return rcv._tab.MutateInt32Slot(8, n)
}

func MoveStart(builder *flatbuffers.Builder) {
	builder.StartObject(3)
}
func MoveAddSrc(builder *flatbuffers.Builder, src int32) {
	builder.PrependInt32Slot(0, src, 0)
}
func MoveAddDst(builder *flatbuffers.Builder, dst int32) {
	builder.PrependInt32Slot(1, dst, 0)
}
func MoveAddPosition(builder *flatbuffers.Builder, position int32) {
	builder.PrependInt32Slot(2, position, 0)
}
func MoveEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type Update struct {
	_tab flatbuffers.Table
}

func GetRootAsUpdate(buf []byte, offset flatbuffers.UOffsetT) *Update {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &Update{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *Update) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *Update) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *Update) Src() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *Update) MutateSrc(n int32) bool {
	return rcv._tab.MutateInt32Slot(4, n)
}

func (rcv *Update) Dst() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *Update) MutateDst(n int32) bool {
	return rcv._tab.MutateInt32Slot(6, n)
}

func UpdateStart(builder *flatbuffers.Builder) {
	builder.StartObject(2)
}
func UpdateAddSrc(builder *flatbuffers.Builder, src int32) {
	builder.PrependInt32Slot(0, src, 0)
}
func UpdateAddDst(builder *flatbuffers.Builder, dst int32) {
	builder.PrependInt32Slot(1, dst, 0)
}
func UpdateEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type Pairs struct {
	_tab flatbuffers.Table
}

func GetRootAsPairs(buf []byte, offset flatbuffers.UOffsetT) *Pairs {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &Pairs{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *Pairs) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *Pairs) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *Pairs) Pair(obj *Pair, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *Pairs) PairLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func PairsStart(builder *flatbuffers.Builder) {
	builder.StartObject(1)
}
func PairsAddPair(builder *flatbuffers.Builder, pair flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(pair), 0)
}
func PairsStartPairVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func PairsEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type Pair struct {
	_tab flatbuffers.Table
}

func GetRootAsPair(buf []byte, offset flatbuffers.UOffsetT) *Pair {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &Pair{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *Pair) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *Pair) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *Pair) Left(obj *PairsDiff) *PairsDiff {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(PairsDiff)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *Pair) Right(obj *PairsDiff) *PairsDiff {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(PairsDiff)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *Pair) Type() CloneType {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return CloneType(rcv._tab.GetInt32(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *Pair) MutateType(n CloneType) bool {
	return rcv._tab.MutateInt32Slot(8, int32(n))
}

func PairStart(builder *flatbuffers.Builder) {
	builder.StartObject(3)
}
func PairAddLeft(builder *flatbuffers.Builder, left flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(left), 0)
}
func PairAddRight(builder *flatbuffers.Builder, right flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(right), 0)
}
func PairAddType(builder *flatbuffers.Builder, type_ CloneType) {
	builder.PrependInt32Slot(2, int32(type_), 0)
}
func PairEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type PairsDiff struct {
	_tab flatbuffers.Table
}

func GetRootAsPairsDiff(buf []byte, offset flatbuffers.UOffsetT) *PairsDiff {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &PairsDiff{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *PairsDiff) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *PairsDiff) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *PairsDiff) Project() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *PairsDiff) LeftLine() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *PairsDiff) MutateLeftLine(n int32) bool {
	return rcv._tab.MutateInt32Slot(6, n)
}

func (rcv *PairsDiff) LeftColumn() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *PairsDiff) MutateLeftColumn(n int32) bool {
	return rcv._tab.MutateInt32Slot(8, n)
}

func (rcv *PairsDiff) RightLine() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *PairsDiff) MutateRightLine(n int32) bool {
	return rcv._tab.MutateInt32Slot(10, n)
}

func (rcv *PairsDiff) RightColumn() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *PairsDiff) MutateRightColumn(n int32) bool {
	return rcv._tab.MutateInt32Slot(12, n)
}

func (rcv *PairsDiff) OldCode(obj *Element) *Element {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(Element)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *PairsDiff) NewCode(obj *Element) *Element {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(Element)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *PairsDiff) Hash() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *PairsDiff) Slices(obj *Slices) *Slices {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(20))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(Slices)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func PairsDiffStart(builder *flatbuffers.Builder) {
	builder.StartObject(9)
}
func PairsDiffAddProject(builder *flatbuffers.Builder, project flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(project), 0)
}
func PairsDiffAddLeftLine(builder *flatbuffers.Builder, leftLine int32) {
	builder.PrependInt32Slot(1, leftLine, 0)
}
func PairsDiffAddLeftColumn(builder *flatbuffers.Builder, leftColumn int32) {
	builder.PrependInt32Slot(2, leftColumn, 0)
}
func PairsDiffAddRightLine(builder *flatbuffers.Builder, rightLine int32) {
	builder.PrependInt32Slot(3, rightLine, 0)
}
func PairsDiffAddRightColumn(builder *flatbuffers.Builder, rightColumn int32) {
	builder.PrependInt32Slot(4, rightColumn, 0)
}
func PairsDiffAddOldCode(builder *flatbuffers.Builder, oldCode flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(5, flatbuffers.UOffsetT(oldCode), 0)
}
func PairsDiffAddNewCode(builder *flatbuffers.Builder, newCode flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(6, flatbuffers.UOffsetT(newCode), 0)
}
func PairsDiffAddHash(builder *flatbuffers.Builder, hash flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(7, flatbuffers.UOffsetT(hash), 0)
}
func PairsDiffAddSlices(builder *flatbuffers.Builder, slices flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(8, flatbuffers.UOffsetT(slices), 0)
}
func PairsDiffEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type Log struct {
	_tab flatbuffers.Table
}

func GetRootAsLog(buf []byte, offset flatbuffers.UOffsetT) *Log {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &Log{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *Log) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *Log) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *Log) Commit(obj *Commit, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *Log) CommitLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *Log) Author(obj *Author, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *Log) AuthorLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func LogStart(builder *flatbuffers.Builder) {
	builder.StartObject(2)
}
func LogAddCommit(builder *flatbuffers.Builder, commit flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(commit), 0)
}
func LogStartCommitVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func LogAddAuthor(builder *flatbuffers.Builder, author flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(author), 0)
}
func LogStartAuthorVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func LogEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type Commit struct {
	_tab flatbuffers.Table
}

func GetRootAsCommit(buf []byte, offset flatbuffers.UOffsetT) *Commit {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &Commit{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *Commit) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *Commit) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *Commit) Id() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *Commit) Msg() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *Commit) AuthorName() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *Commit) AuthorEmail() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *Commit) AuthorTime() int64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.GetInt64(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *Commit) MutateAuthorTime(n int64) bool {
	return rcv._tab.MutateInt64Slot(12, n)
}

func (rcv *Commit) CommitterName() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *Commit) CommitterEmail() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *Commit) CommitterTime() int64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		return rcv._tab.GetInt64(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *Commit) MutateCommitterTime(n int64) bool {
	return rcv._tab.MutateInt64Slot(18, n)
}

func (rcv *Commit) Diff(obj *LogDiff, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(20))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *Commit) DiffLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(20))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *Commit) Slice(obj *Slices) *Slices {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(22))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(Slices)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func CommitStart(builder *flatbuffers.Builder) {
	builder.StartObject(10)
}
func CommitAddId(builder *flatbuffers.Builder, id flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(id), 0)
}
func CommitAddMsg(builder *flatbuffers.Builder, msg flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(msg), 0)
}
func CommitAddAuthorName(builder *flatbuffers.Builder, authorName flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(authorName), 0)
}
func CommitAddAuthorEmail(builder *flatbuffers.Builder, authorEmail flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(authorEmail), 0)
}
func CommitAddAuthorTime(builder *flatbuffers.Builder, authorTime int64) {
	builder.PrependInt64Slot(4, authorTime, 0)
}
func CommitAddCommitterName(builder *flatbuffers.Builder, committerName flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(5, flatbuffers.UOffsetT(committerName), 0)
}
func CommitAddCommitterEmail(builder *flatbuffers.Builder, committerEmail flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(6, flatbuffers.UOffsetT(committerEmail), 0)
}
func CommitAddCommitterTime(builder *flatbuffers.Builder, committerTime int64) {
	builder.PrependInt64Slot(7, committerTime, 0)
}
func CommitAddDiff(builder *flatbuffers.Builder, diff flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(8, flatbuffers.UOffsetT(diff), 0)
}
func CommitStartDiffVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func CommitAddSlice(builder *flatbuffers.Builder, slice flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(9, flatbuffers.UOffsetT(slice), 0)
}
func CommitEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type LogDiff struct {
	_tab flatbuffers.Table
}

func GetRootAsLogDiff(buf []byte, offset flatbuffers.UOffsetT) *LogDiff {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &LogDiff{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *LogDiff) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *LogDiff) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *LogDiff) A() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *LogDiff) B() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *LogDiff) IsNew() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

func (rcv *LogDiff) MutateIsNew(n bool) bool {
	return rcv._tab.MutateBoolSlot(8, n)
}

func (rcv *LogDiff) IsCode() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *LogDiff) IndexFrom() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *LogDiff) IndexTo() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *LogDiff) Mode() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *LogDiff) Hunk(obj *Hunk, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *LogDiff) HunkLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func LogDiffStart(builder *flatbuffers.Builder) {
	builder.StartObject(8)
}
func LogDiffAddA(builder *flatbuffers.Builder, a flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(a), 0)
}
func LogDiffAddB(builder *flatbuffers.Builder, b flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(b), 0)
}
func LogDiffAddIsNew(builder *flatbuffers.Builder, isNew bool) {
	builder.PrependBoolSlot(2, isNew, false)
}
func LogDiffAddIsCode(builder *flatbuffers.Builder, isCode flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(isCode), 0)
}
func LogDiffAddIndexFrom(builder *flatbuffers.Builder, indexFrom flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(4, flatbuffers.UOffsetT(indexFrom), 0)
}
func LogDiffAddIndexTo(builder *flatbuffers.Builder, indexTo flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(5, flatbuffers.UOffsetT(indexTo), 0)
}
func LogDiffAddMode(builder *flatbuffers.Builder, mode flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(6, flatbuffers.UOffsetT(mode), 0)
}
func LogDiffAddHunk(builder *flatbuffers.Builder, hunk flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(7, flatbuffers.UOffsetT(hunk), 0)
}
func LogDiffStartHunkVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func LogDiffEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type Hunk struct {
	_tab flatbuffers.Table
}

func GetRootAsHunk(buf []byte, offset flatbuffers.UOffsetT) *Hunk {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &Hunk{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *Hunk) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *Hunk) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *Hunk) FromLineno() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *Hunk) MutateFromLineno(n int32) bool {
	return rcv._tab.MutateInt32Slot(4, n)
}

func (rcv *Hunk) FromColumn() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *Hunk) MutateFromColumn(n int32) bool {
	return rcv._tab.MutateInt32Slot(6, n)
}

func (rcv *Hunk) ToLineno() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *Hunk) MutateToLineno(n int32) bool {
	return rcv._tab.MutateInt32Slot(8, n)
}

func (rcv *Hunk) ToColumn() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *Hunk) MutateToColumn(n int32) bool {
	return rcv._tab.MutateInt32Slot(10, n)
}

func (rcv *Hunk) Context() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *Hunk) Element(obj *Element, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *Hunk) ElementLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *Hunk) Graph(obj *Graph, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *Hunk) GraphLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *Hunk) Mod(obj *ModLine, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *Hunk) ModLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *Hunk) Slice(obj *Slices) *Slices {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(20))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(Slices)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func HunkStart(builder *flatbuffers.Builder) {
	builder.StartObject(9)
}
func HunkAddFromLineno(builder *flatbuffers.Builder, fromLineno int32) {
	builder.PrependInt32Slot(0, fromLineno, 0)
}
func HunkAddFromColumn(builder *flatbuffers.Builder, fromColumn int32) {
	builder.PrependInt32Slot(1, fromColumn, 0)
}
func HunkAddToLineno(builder *flatbuffers.Builder, toLineno int32) {
	builder.PrependInt32Slot(2, toLineno, 0)
}
func HunkAddToColumn(builder *flatbuffers.Builder, toColumn int32) {
	builder.PrependInt32Slot(3, toColumn, 0)
}
func HunkAddContext(builder *flatbuffers.Builder, context flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(4, flatbuffers.UOffsetT(context), 0)
}
func HunkAddElement(builder *flatbuffers.Builder, element flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(5, flatbuffers.UOffsetT(element), 0)
}
func HunkStartElementVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func HunkAddGraph(builder *flatbuffers.Builder, graph flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(6, flatbuffers.UOffsetT(graph), 0)
}
func HunkStartGraphVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func HunkAddMod(builder *flatbuffers.Builder, mod flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(7, flatbuffers.UOffsetT(mod), 0)
}
func HunkStartModVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func HunkAddSlice(builder *flatbuffers.Builder, slice flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(8, flatbuffers.UOffsetT(slice), 0)
}
func HunkEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type ModLine struct {
	_tab flatbuffers.Table
}

func GetRootAsModLine(buf []byte, offset flatbuffers.UOffsetT) *ModLine {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &ModLine{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *ModLine) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *ModLine) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *ModLine) Line() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *ModLine) IsAdd() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

func (rcv *ModLine) MutateIsAdd(n bool) bool {
	return rcv._tab.MutateBoolSlot(6, n)
}

func (rcv *ModLine) IsDel() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

func (rcv *ModLine) MutateIsDel(n bool) bool {
	return rcv._tab.MutateBoolSlot(8, n)
}

func ModLineStart(builder *flatbuffers.Builder) {
	builder.StartObject(3)
}
func ModLineAddLine(builder *flatbuffers.Builder, line flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(line), 0)
}
func ModLineAddIsAdd(builder *flatbuffers.Builder, isAdd bool) {
	builder.PrependBoolSlot(1, isAdd, false)
}
func ModLineAddIsDel(builder *flatbuffers.Builder, isDel bool) {
	builder.PrependBoolSlot(2, isDel, false)
}
func ModLineEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type Author struct {
	_tab flatbuffers.Table
}

func GetRootAsAuthor(buf []byte, offset flatbuffers.UOffsetT) *Author {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &Author{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *Author) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *Author) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *Author) Id() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *Author) MutateId(n int32) bool {
	return rcv._tab.MutateInt32Slot(4, n)
}

func (rcv *Author) Name() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *Author) Email() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func AuthorStart(builder *flatbuffers.Builder) {
	builder.StartObject(3)
}
func AuthorAddId(builder *flatbuffers.Builder, id int32) {
	builder.PrependInt32Slot(0, id, 0)
}
func AuthorAddName(builder *flatbuffers.Builder, name flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(name), 0)
}
func AuthorAddEmail(builder *flatbuffers.Builder, email flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(email), 0)
}
func AuthorEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type Slices struct {
	_tab flatbuffers.Table
}

func GetRootAsSlices(buf []byte, offset flatbuffers.UOffsetT) *Slices {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &Slices{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *Slices) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *Slices) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *Slices) Slice(obj *Slice, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *Slices) SliceLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func SlicesStart(builder *flatbuffers.Builder) {
	builder.StartObject(1)
}
func SlicesAddSlice(builder *flatbuffers.Builder, slice flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(slice), 0)
}
func SlicesStartSliceVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func SlicesEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type Slice struct {
	_tab flatbuffers.Table
}

func GetRootAsSlice(buf []byte, offset flatbuffers.UOffsetT) *Slice {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &Slice{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *Slice) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *Slice) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *Slice) File(obj *SourceFile, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *Slice) FileLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *Slice) Hash() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func SliceStart(builder *flatbuffers.Builder) {
	builder.StartObject(2)
}
func SliceAddFile(builder *flatbuffers.Builder, file flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(file), 0)
}
func SliceStartFileVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func SliceAddHash(builder *flatbuffers.Builder, hash flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(hash), 0)
}
func SliceEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type SourceFile struct {
	_tab flatbuffers.Table
}

func GetRootAsSourceFile(buf []byte, offset flatbuffers.UOffsetT) *SourceFile {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &SourceFile{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *SourceFile) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *SourceFile) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *SourceFile) Function(obj *Function, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *SourceFile) FunctionLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *SourceFile) Name() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *SourceFile) Type() ChangeType {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return ChangeType(rcv._tab.GetInt32(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *SourceFile) MutateType(n ChangeType) bool {
	return rcv._tab.MutateInt32Slot(8, int32(n))
}

func SourceFileStart(builder *flatbuffers.Builder) {
	builder.StartObject(3)
}
func SourceFileAddFunction(builder *flatbuffers.Builder, function flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(function), 0)
}
func SourceFileStartFunctionVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func SourceFileAddName(builder *flatbuffers.Builder, name flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(name), 0)
}
func SourceFileAddType(builder *flatbuffers.Builder, type_ ChangeType) {
	builder.PrependInt32Slot(2, int32(type_), 0)
}
func SourceFileEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type Function struct {
	_tab flatbuffers.Table
}

func GetRootAsFunction(buf []byte, offset flatbuffers.UOffsetT) *Function {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &Function{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *Function) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *Function) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *Function) Variable(obj *Variable, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *Function) VariableLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *Function) Name() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *Function) Type() ChangeType {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return ChangeType(rcv._tab.GetInt32(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *Function) MutateType(n ChangeType) bool {
	return rcv._tab.MutateInt32Slot(8, int32(n))
}

func FunctionStart(builder *flatbuffers.Builder) {
	builder.StartObject(3)
}
func FunctionAddVariable(builder *flatbuffers.Builder, variable flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(variable), 0)
}
func FunctionStartVariableVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func FunctionAddName(builder *flatbuffers.Builder, name flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(name), 0)
}
func FunctionAddType(builder *flatbuffers.Builder, type_ ChangeType) {
	builder.PrependInt32Slot(2, int32(type_), 0)
}
func FunctionEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type Variable struct {
	_tab flatbuffers.Table
}

func GetRootAsVariable(buf []byte, offset flatbuffers.UOffsetT) *Variable {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &Variable{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *Variable) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *Variable) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *Variable) Name() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *Variable) Pos(obj *Position) *Position {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(Position)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *Variable) Type() ChangeType {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return ChangeType(rcv._tab.GetInt32(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *Variable) MutateType(n ChangeType) bool {
	return rcv._tab.MutateInt32Slot(8, int32(n))
}

func (rcv *Variable) Defn(obj *Position, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *Variable) DefnLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *Variable) Use(obj *Position, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *Variable) UseLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *Variable) Dvar(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *Variable) DvarLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *Variable) Alias(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *Variable) AliasLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *Variable) Cfunc(obj *FunctionDecl, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *Variable) CfuncLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func VariableStart(builder *flatbuffers.Builder) {
	builder.StartObject(8)
}
func VariableAddName(builder *flatbuffers.Builder, name flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(name), 0)
}
func VariableAddPos(builder *flatbuffers.Builder, pos flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(pos), 0)
}
func VariableAddType(builder *flatbuffers.Builder, type_ ChangeType) {
	builder.PrependInt32Slot(2, int32(type_), 0)
}
func VariableAddDefn(builder *flatbuffers.Builder, defn flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(defn), 0)
}
func VariableStartDefnVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func VariableAddUse(builder *flatbuffers.Builder, use flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(4, flatbuffers.UOffsetT(use), 0)
}
func VariableStartUseVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func VariableAddDvar(builder *flatbuffers.Builder, dvar flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(5, flatbuffers.UOffsetT(dvar), 0)
}
func VariableStartDvarVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func VariableAddAlias(builder *flatbuffers.Builder, alias flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(6, flatbuffers.UOffsetT(alias), 0)
}
func VariableStartAliasVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func VariableAddCfunc(builder *flatbuffers.Builder, cfunc flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(7, flatbuffers.UOffsetT(cfunc), 0)
}
func VariableStartCfuncVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func VariableEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type Position struct {
	_tab flatbuffers.Table
}

func GetRootAsPosition(buf []byte, offset flatbuffers.UOffsetT) *Position {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &Position{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *Position) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *Position) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *Position) Location() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *Position) Type() ChangeType {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return ChangeType(rcv._tab.GetInt32(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *Position) MutateType(n ChangeType) bool {
	return rcv._tab.MutateInt32Slot(6, int32(n))
}

func (rcv *Position) DeltaLocation() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func PositionStart(builder *flatbuffers.Builder) {
	builder.StartObject(3)
}
func PositionAddLocation(builder *flatbuffers.Builder, location flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(location), 0)
}
func PositionAddType(builder *flatbuffers.Builder, type_ ChangeType) {
	builder.PrependInt32Slot(1, int32(type_), 0)
}
func PositionAddDeltaLocation(builder *flatbuffers.Builder, deltaLocation flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(deltaLocation), 0)
}
func PositionEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type FunctionDecl struct {
	_tab flatbuffers.Table
}

func GetRootAsFunctionDecl(buf []byte, offset flatbuffers.UOffsetT) *FunctionDecl {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &FunctionDecl{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *FunctionDecl) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *FunctionDecl) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *FunctionDecl) Name() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *FunctionDecl) Location() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func FunctionDeclStart(builder *flatbuffers.Builder) {
	builder.StartObject(2)
}
func FunctionDeclAddName(builder *flatbuffers.Builder, name flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(name), 0)
}
func FunctionDeclAddLocation(builder *flatbuffers.Builder, location flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(location), 0)
}
func FunctionDeclEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type Bugs struct {
	_tab flatbuffers.Table
}

func GetRootAsBugs(buf []byte, offset flatbuffers.UOffsetT) *Bugs {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &Bugs{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *Bugs) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *Bugs) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *Bugs) Repository() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *Bugs) Bug(obj *Bug, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *Bugs) BugLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func BugsStart(builder *flatbuffers.Builder) {
	builder.StartObject(2)
}
func BugsAddRepository(builder *flatbuffers.Builder, repository flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(repository), 0)
}
func BugsAddBug(builder *flatbuffers.Builder, bug flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(bug), 0)
}
func BugsStartBugVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func BugsEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type Bug struct {
	_tab flatbuffers.Table
}

func GetRootAsBug(buf []byte, offset flatbuffers.UOffsetT) *Bug {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &Bug{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *Bug) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *Bug) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *Bug) Id() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *Bug) Opendate() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *Bug) Fixdate() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *Bug) Buginfo(obj *Info) *Info {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(Info)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *Bug) FixedFile(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *Bug) FixedFileLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func BugStart(builder *flatbuffers.Builder) {
	builder.StartObject(5)
}
func BugAddId(builder *flatbuffers.Builder, id flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(id), 0)
}
func BugAddOpendate(builder *flatbuffers.Builder, opendate flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(opendate), 0)
}
func BugAddFixdate(builder *flatbuffers.Builder, fixdate flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(fixdate), 0)
}
func BugAddBuginfo(builder *flatbuffers.Builder, buginfo flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(buginfo), 0)
}
func BugAddFixedFile(builder *flatbuffers.Builder, fixedFile flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(4, flatbuffers.UOffsetT(fixedFile), 0)
}
func BugStartFixedFileVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func BugEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type Info struct {
	_tab flatbuffers.Table
}

func GetRootAsInfo(buf []byte, offset flatbuffers.UOffsetT) *Info {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &Info{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *Info) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *Info) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *Info) Summary() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *Info) Description() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func InfoStart(builder *flatbuffers.Builder) {
	builder.StartObject(2)
}
func InfoAddSummary(builder *flatbuffers.Builder, summary flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(summary), 0)
}
func InfoAddDescription(builder *flatbuffers.Builder, description flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(description), 0)
}
func InfoEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type Graph struct {
	_tab flatbuffers.Table
}

func GetRootAsGraph(buf []byte, offset flatbuffers.UOffsetT) *Graph {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &Graph{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *Graph) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *Graph) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *Graph) Unit(obj *TreeUnit, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *Graph) UnitLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func GraphStart(builder *flatbuffers.Builder) {
	builder.StartObject(1)
}
func GraphAddUnit(builder *flatbuffers.Builder, unit flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(unit), 0)
}
func GraphStartUnitVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func GraphEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type Edge struct {
	_tab flatbuffers.Table
}

func GetRootAsEdge(buf []byte, offset flatbuffers.UOffsetT) *Edge {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &Edge{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *Edge) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *Edge) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *Edge) Node1() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *Edge) MutateNode1(n int32) bool {
	return rcv._tab.MutateInt32Slot(4, n)
}

func (rcv *Edge) Node2() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *Edge) MutateNode2(n int32) bool {
	return rcv._tab.MutateInt32Slot(6, n)
}

func EdgeStart(builder *flatbuffers.Builder) {
	builder.StartObject(2)
}
func EdgeAddNode1(builder *flatbuffers.Builder, node1 int32) {
	builder.PrependInt32Slot(0, node1, 0)
}
func EdgeAddNode2(builder *flatbuffers.Builder, node2 int32) {
	builder.PrependInt32Slot(1, node2, 0)
}
func EdgeEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type NodeLabel struct {
	_tab flatbuffers.Table
}

func GetRootAsNodeLabel(buf []byte, offset flatbuffers.UOffsetT) *NodeLabel {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &NodeLabel{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *NodeLabel) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *NodeLabel) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *NodeLabel) Node() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *NodeLabel) MutateNode(n int32) bool {
	return rcv._tab.MutateInt32Slot(4, n)
}

func (rcv *NodeLabel) Label() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func NodeLabelStart(builder *flatbuffers.Builder) {
	builder.StartObject(2)
}
func NodeLabelAddNode(builder *flatbuffers.Builder, node int32) {
	builder.PrependInt32Slot(0, node, 0)
}
func NodeLabelAddLabel(builder *flatbuffers.Builder, label flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(label), 0)
}
func NodeLabelEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type NodeType struct {
	_tab flatbuffers.Table
}

func GetRootAsNodeType(buf []byte, offset flatbuffers.UOffsetT) *NodeType {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &NodeType{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *NodeType) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *NodeType) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *NodeType) Node() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *NodeType) MutateNode(n int32) bool {
	return rcv._tab.MutateInt32Slot(4, n)
}

func (rcv *NodeType) Type() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func NodeTypeStart(builder *flatbuffers.Builder) {
	builder.StartObject(2)
}
func NodeTypeAddNode(builder *flatbuffers.Builder, node int32) {
	builder.PrependInt32Slot(0, node, 0)
}
func NodeTypeAddType(builder *flatbuffers.Builder, type_ flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(type_), 0)
}
func NodeTypeEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type ContextEdges struct {
	_tab flatbuffers.Table
}

func GetRootAsContextEdges(buf []byte, offset flatbuffers.UOffsetT) *ContextEdges {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &ContextEdges{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *ContextEdges) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *ContextEdges) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *ContextEdges) NextToken(obj *Edge, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *ContextEdges) NextTokenLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *ContextEdges) Child(obj *Edge, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *ContextEdges) ChildLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *ContextEdges) LastLexicalUse(obj *Edge, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *ContextEdges) LastLexicalUseLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *ContextEdges) LastUse(obj *Edge, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *ContextEdges) LastUseLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *ContextEdges) LastWrite(obj *Edge, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *ContextEdges) LastWriteLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *ContextEdges) ReturnsTo(obj *Edge, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *ContextEdges) ReturnsToLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *ContextEdges) ComputesFrom(obj *Edge, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *ContextEdges) ComputesFromLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func ContextEdgesStart(builder *flatbuffers.Builder) {
	builder.StartObject(7)
}
func ContextEdgesAddNextToken(builder *flatbuffers.Builder, nextToken flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(nextToken), 0)
}
func ContextEdgesStartNextTokenVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func ContextEdgesAddChild(builder *flatbuffers.Builder, child flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(child), 0)
}
func ContextEdgesStartChildVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func ContextEdgesAddLastLexicalUse(builder *flatbuffers.Builder, lastLexicalUse flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(lastLexicalUse), 0)
}
func ContextEdgesStartLastLexicalUseVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func ContextEdgesAddLastUse(builder *flatbuffers.Builder, lastUse flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(lastUse), 0)
}
func ContextEdgesStartLastUseVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func ContextEdgesAddLastWrite(builder *flatbuffers.Builder, lastWrite flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(4, flatbuffers.UOffsetT(lastWrite), 0)
}
func ContextEdgesStartLastWriteVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func ContextEdgesAddReturnsTo(builder *flatbuffers.Builder, returnsTo flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(5, flatbuffers.UOffsetT(returnsTo), 0)
}
func ContextEdgesStartReturnsToVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func ContextEdgesAddComputesFrom(builder *flatbuffers.Builder, computesFrom flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(6, flatbuffers.UOffsetT(computesFrom), 0)
}
func ContextEdgesStartComputesFromVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func ContextEdgesEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type ContextGraph struct {
	_tab flatbuffers.Table
}

func GetRootAsContextGraph(buf []byte, offset flatbuffers.UOffsetT) *ContextGraph {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &ContextGraph{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *ContextGraph) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *ContextGraph) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *ContextGraph) Edges(obj *ContextEdges) *ContextEdges {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(ContextEdges)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *ContextGraph) NodeLabel(obj *NodeLabel, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *ContextGraph) NodeLabelLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *ContextGraph) NodeType(obj *NodeType, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *ContextGraph) NodeTypeLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func ContextGraphStart(builder *flatbuffers.Builder) {
	builder.StartObject(3)
}
func ContextGraphAddEdges(builder *flatbuffers.Builder, edges flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(edges), 0)
}
func ContextGraphAddNodeLabel(builder *flatbuffers.Builder, nodeLabel flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(nodeLabel), 0)
}
func ContextGraphStartNodeLabelVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func ContextGraphAddNodeType(builder *flatbuffers.Builder, nodeType flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(nodeType), 0)
}
func ContextGraphStartNodeTypeVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func ContextGraphEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type SymbolCandidate struct {
	_tab flatbuffers.Table
}

func GetRootAsSymbolCandidate(buf []byte, offset flatbuffers.UOffsetT) *SymbolCandidate {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &SymbolCandidate{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *SymbolCandidate) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *SymbolCandidate) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *SymbolCandidate) SymbolDummyNode() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *SymbolCandidate) MutateSymbolDummyNode(n int32) bool {
	return rcv._tab.MutateInt32Slot(4, n)
}

func (rcv *SymbolCandidate) SymbolName() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *SymbolCandidate) IsCorrect() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

func (rcv *SymbolCandidate) MutateIsCorrect(n bool) bool {
	return rcv._tab.MutateBoolSlot(8, n)
}

func SymbolCandidateStart(builder *flatbuffers.Builder) {
	builder.StartObject(3)
}
func SymbolCandidateAddSymbolDummyNode(builder *flatbuffers.Builder, symbolDummyNode int32) {
	builder.PrependInt32Slot(0, symbolDummyNode, 0)
}
func SymbolCandidateAddSymbolName(builder *flatbuffers.Builder, symbolName flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(symbolName), 0)
}
func SymbolCandidateAddIsCorrect(builder *flatbuffers.Builder, isCorrect bool) {
	builder.PrependBoolSlot(2, isCorrect, false)
}
func SymbolCandidateEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type TreeUnit struct {
	_tab flatbuffers.Table
}

func GetRootAsTreeUnit(buf []byte, offset flatbuffers.UOffsetT) *TreeUnit {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &TreeUnit{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *TreeUnit) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *TreeUnit) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *TreeUnit) Filename() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *TreeUnit) SlotTokenIdx() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *TreeUnit) MutateSlotTokenIdx(n int32) bool {
	return rcv._tab.MutateInt32Slot(6, n)
}

func (rcv *TreeUnit) Graph(obj *ContextGraph) *ContextGraph {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(ContextGraph)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *TreeUnit) SlotDummyNode() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *TreeUnit) MutateSlotDummyNode(n int32) bool {
	return rcv._tab.MutateInt32Slot(10, n)
}

func (rcv *TreeUnit) SymbolCandidate(obj *SymbolCandidate, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *TreeUnit) SymbolCandidateLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func TreeUnitStart(builder *flatbuffers.Builder) {
	builder.StartObject(5)
}
func TreeUnitAddFilename(builder *flatbuffers.Builder, filename flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(filename), 0)
}
func TreeUnitAddSlotTokenIdx(builder *flatbuffers.Builder, slotTokenIdx int32) {
	builder.PrependInt32Slot(1, slotTokenIdx, 0)
}
func TreeUnitAddGraph(builder *flatbuffers.Builder, graph flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(graph), 0)
}
func TreeUnitAddSlotDummyNode(builder *flatbuffers.Builder, SlotDummyNode int32) {
	builder.PrependInt32Slot(3, SlotDummyNode, 0)
}
func TreeUnitAddSymbolCandidate(builder *flatbuffers.Builder, symbolCandidate flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(4, flatbuffers.UOffsetT(symbolCandidate), 0)
}
func TreeUnitStartSymbolCandidateVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func TreeUnitEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type Data struct {
	_tab flatbuffers.Table
}

func GetRootAsData(buf []byte, offset flatbuffers.UOffsetT) *Data {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &Data{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *Data) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *Data) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *Data) RecordType(obj *Anonymous2) *Anonymous2 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(Anonymous2)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func DataStart(builder *flatbuffers.Builder) {
	builder.StartObject(1)
}
func DataAddRecordType(builder *flatbuffers.Builder, RecordType flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(RecordType), 0)
}
func DataEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type Anonymous2 struct {
	_tab flatbuffers.Table
}

func GetRootAsAnonymous2(buf []byte, offset flatbuffers.UOffsetT) *Anonymous2 {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &Anonymous2{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *Anonymous2) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *Anonymous2) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *Anonymous2) Element(obj *Element) *Element {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(Element)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *Anonymous2) Log(obj *Log) *Log {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(Log)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *Anonymous2) Delta(obj *Delta) *Delta {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(Delta)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *Anonymous2) Pairs(obj *Pairs) *Pairs {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(Pairs)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *Anonymous2) Slices(obj *Slices) *Slices {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(Slices)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *Anonymous2) Bugs(obj *Bugs) *Bugs {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(Bugs)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *Anonymous2) Graph(obj *Graph) *Graph {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(Graph)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func Anonymous2Start(builder *flatbuffers.Builder) {
	builder.StartObject(7)
}
func Anonymous2AddElement(builder *flatbuffers.Builder, element flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(element), 0)
}
func Anonymous2AddLog(builder *flatbuffers.Builder, log flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(log), 0)
}
func Anonymous2AddDelta(builder *flatbuffers.Builder, delta flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(delta), 0)
}
func Anonymous2AddPairs(builder *flatbuffers.Builder, pairs flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(pairs), 0)
}
func Anonymous2AddSlices(builder *flatbuffers.Builder, slices flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(4, flatbuffers.UOffsetT(slices), 0)
}
func Anonymous2AddBugs(builder *flatbuffers.Builder, bugs flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(5, flatbuffers.UOffsetT(bugs), 0)
}
func Anonymous2AddGraph(builder *flatbuffers.Builder, graph flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(6, flatbuffers.UOffsetT(graph), 0)
}
func Anonymous2End(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
